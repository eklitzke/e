import datetime
import hashlib
import lzma
import optparse
import pprint
import re
import subprocess
import sys
try:
    import jsmin
except ImportError:
    pass

h_template = """
// -*- C++ -*-
// Copyright %(current_year)d, Evan Klitzke <evan@eklitzke.org>
//
// This is the header file for the C++ representation of the "core" JavaScript
// code. This exists so that we can have a safe representation of the core code,
// and ship a working binary without any extra files.
//
// This file is AUTOGENERATED by gen_bundled_core.py, do not edit by hand!
//
// Contents generated %(gentime)s.

#ifndef SRC_BUNDLED_CORE_H_
#define SRC_BUNDLED_CORE_H_

#include <v8.h>

namespace e {
v8::Local<v8::Script> GetCoreScript();
}
#endif  // SRC_BUNDLED_CORE_H_
"""

cc_template = """
// -*- C++ -*-
// Copyright %(current_year)d, Evan Klitzke <evan@eklitzke.org>
//
// This file is AUTOGENERATED by gen_bundled_core.py, do not edit by hand!
//
// Contents generated %(gentime)s.

#include "./bundled_core.h"

#include <lzma.h>
#include <v8.h>
#include <cstring>

#include "./assert.h"

namespace {
// This is the "minified" core.js code, as a C string. The reason for
// obfuscating it like this is simply to avoid having to escape the string in a
// way that's safe for C. Python's built in "string_escape" codec comes close
// but doesn't quite grok C.
const uint8_t core_src[%(compressed_len)d] = {
%(src)s
};

// Pre-compilation data
const uint8_t precompiled_src[%(precompilation_len)d] = {
%(precompiled_src)s
};
}

namespace e {
v8::Local<v8::Script> GetCoreScript() {
  v8::HandleScope scope;

  uint8_t *buf = new uint8_t[%(uncompressed_len)d];
  uint8_t bufout[8096];
  lzma_stream lstr = LZMA_STREAM_INIT;
  if (lzma_auto_decoder(&lstr, UINT64_MAX, 0) != LZMA_OK) {
    e::Panic("failed to open LZMA decoder");
  }
  lstr.next_in = core_src;
  lstr.avail_in = sizeof(core_src);
  lstr.next_out = buf;
  lstr.avail_out = %(uncompressed_len)d;
  int ret = lzma_code(&lstr, LZMA_RUN);
  if (ret != LZMA_STREAM_END) {
    if (ret != LZMA_OK) {
      e::Panic("failed to lzma_code at LZMA_RUN, code %%d", ret);
    }
    size_t written = %(uncompressed_len)d - lstr.avail_out;
    while (true) {
      lstr.next_out = bufout;
      lstr.avail_out = sizeof(bufout);
      ret = lzma_code(&lstr, LZMA_FINISH);
      if (ret != LZMA_OK && ret != LZMA_STREAM_END) {
        lzma_end(&lstr);
        e::Panic("Failed to lzma_code at LZMA_FINISH");
      }
      size_t encoded = sizeof(bufout) - lstr.avail_out;
      memcpy(buf + written, bufout, encoded);
      written += encoded;
      if (ret == LZMA_STREAM_END) {
        if (written != %(uncompressed_len)d) {
          Panic("wrote %%zd bytes but wanted to write %%zd", written, %(uncompressed_len)d);
        }
        break;
      }
    }
  }

  v8::Local<v8::String> src = v8::String::New(
    reinterpret_cast<const char *>(buf), %(uncompressed_len)d);
  v8::ScriptData *pre_data = v8::ScriptData::New(
    reinterpret_cast<const char *>(precompiled_src), sizeof(precompiled_src));
  v8::Local<v8::Script> script = v8::Script::Compile(src, nullptr, pre_data);
  delete pre_data;
  delete[] buf;
  return scope.Close(script);
}
}
"""

builtin_modules = frozenset(['curses', 'errno', 'signal', 'sys'])
require_regex = re.compile('require\\(["\'](.*?)["\']\\)', re.MULTILINE)

def expand_requires(contents):
    offset = 0
    while True:
        m = require_regex.search(contents, offset)
        if not m:
            break
        fname = m.groups()[0]
        if fname in builtin_modules:
            offset = m.end()
            continue

        prefix = contents[:m.start()]
        suffix = contents[m.end():]

        with open(m.groups()[0]) as f:
            f_contents = f.read()
        contents = (prefix + "(function(){\"use strict\";var exports={};" +
                    f_contents + ";return exports;})()" + suffix)
        offset = m.start()
    return contents

def maybe_replace_file(name, contents):
    # to avoid rebuilding too much (specifically rebuiding state.cc) when
    # bundled_core.{h,cc} are re-generated, we only re-write the contents of
    # files when they actually change
    try:
        with open(name) as f:
            file_hash = hashlib.sha1(f.read()).digest()
    except IOError:
        file_hash = ''
    if not contents.endswith('\n'):
        contents += '\n'
    content_hash = hashlib.sha1(contents).digest()
    if file_hash != content_hash:
        with open(name, 'w') as wf:
            wf.write(contents)

def c_escape_binary_data(data):
    line_size = 13
    splitsrc = []
    while data:
        splitsrc.append(data[:line_size])
        data = data[line_size:]

    escaped_output = []
    for line in splitsrc[:-1]:
        l = ', '.join('0x%02x' % ord(c) for c in line) + ','
        escaped_output.append('  ' + l)
    escaped_output.append('  ' + ', '.join('0x%02x' % ord(c) for c in splitsrc[-1]))
    return '\n'.join(escaped_output)

def write_output(code, uncompressed_len, precompilation, output):
    src = c_escape_binary_data(code)
    precompiled_src = c_escape_binary_data(precompilation)

    current_year = datetime.datetime.today().year
    gentime = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    cc_src = cc_template.strip() % {
        'current_year': current_year,
        'gentime': gentime,
        'src': src,
        'compressed_len': len(code),
        'uncompressed_len': uncompressed_len,
        'precompiled_src': precompiled_src,
        'precompilation_len': len(precompilation)
        }
    h_src = h_template.strip() % {
        'current_year': current_year,
        'gentime': gentime
        }

    maybe_replace_file(output + '.h', h_src)
    maybe_replace_file(output + '.cc', cc_src)

    # create a fake .bundled_core file to please `make'; the reason this is
    # necessary is because Make will get confused if we don't actually end up
    # updating the .h or .cc files
    with open('src/.bundled_core', 'w') as b:
        pass

if __name__ == '__main__':
    parser = optparse.OptionParser()
    parser.add_option('--no-expand-requires', dest='expand_requires', default=True,
                      action='store_false', help="Don't expand requires()")
    parser.add_option('-o', '--outfile', default='src/bundled_core', help='Output file to emit.')
    opts, args = parser.parse_args()
    if not opts.outfile:
        parser.error('must have an outfile')
        sys.exit(1)

    code = ['"use strict";']  # enforce strict mode for bundled JS, gh-15

    for filename in args:
        with open(filename) as f:
            code.append(f.read())

    code = '\n'.join(code).strip()
    if opts.expand_requires:
        code = expand_requires(code)

    uncompressed_len = len(code)
    compressor = lzma.LZMACompressor()
    compressed_output = compressor.compress(code);
    compressed_output += compressor.flush()

    p = subprocess.Popen(['scripts/precompile'],
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    p.stdin.write(code)
    out, err = p.communicate()
    assert not err, err
    write_output(compressed_output, uncompressed_len, out, opts.outfile)
