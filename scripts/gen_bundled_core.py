import datetime
import hashlib
import optparse
import pprint
import re
import subprocess
import sys
import urllib
import urllib2
import json
try:
    import jsmin
except ImportError:
    pass

h_template = """
// -*- C++ -*-
// Copyright %(current_year)d, Evan Klitzke <evan@eklitzke.org>
//
// This is the header file for the C++ representation of the "core" JavaScript
// code. This exists so that we can have a safe representation of the core code,
// and ship a working binary without any extra files.
//
// This file is AUTOGENERATED by gen_bundled_core.py, do not edit by hand!
//
// Contents generated %(gentime)s.

#ifndef SRC_BUNDLED_CORE_H_
#define SRC_BUNDLED_CORE_H_

#include <v8.h>

namespace e {
v8::Local<v8::Script> GetCoreScript();
}
#endif  // SRC_BUNDLED_CORE_H_
"""

cc_template = """
// -*- C++ -*-
// Copyright %(current_year)d, Evan Klitzke <evan@eklitzke.org>
//
// This file is AUTOGENERATED by gen_bundled_core.py, do not edit by hand!
//
// Contents generated %(gentime)s.

#include <v8.h>

namespace {
// This is the "minified" core.js code, as a C string. The reason for
// obfuscating it like this is simply to avoid having to escape the string in a
// way that's safe for C. Python's built in "string_escape" codec comes close
// but doesn't quite grok C.
//
// In this compilation, core_src is %(src_len)d bytes long.
const char *core_src = (
%(src)s);

// Pre-compilation data, %(precompilation_len)d bytes
const char *precompiled_src = (
%(precompiled_src)s);
}

namespace e {
v8::Local<v8::Script> GetCoreScript() {
  v8::HandleScope scope;
  v8::Local<v8::String> src = v8::String::New(core_src, %(src_len)d);
  v8::ScriptData *pre_data = v8::ScriptData::New(precompiled_src, %(precompilation_len)d);
  v8::Local<v8::Script> script = v8::Script::Compile(src, nullptr, pre_data);
  delete pre_data;
  return scope.Close(script);
}
}
"""

builtin_modules = frozenset(['curses', 'errno', 'signal', 'sys'])
require_regex = re.compile('require\\(["\'](.*?)["\']\\)', re.MULTILINE)

def expand_requires(contents):
    offset = 0
    while True:
        m = require_regex.search(contents, offset)
        if not m:
            break
        fname = m.groups()[0]
        if fname in builtin_modules:
            offset = m.end()
            continue

        prefix = contents[:m.start()]
        suffix = contents[m.end():]

        with open(m.groups()[0]) as f:
            f_contents = f.read()
        contents = (prefix + "(function(){\"use strict\";var exports={};" +
                    f_contents + ";return exports;})()" + suffix)
        offset = m.start()
    return contents

def get_closure_code(code, use_advanced=False):
    request_params = [
        ('js_code', code),
        ('compilation_level', 'ADVANCED_OPTIMIZATIONS' if use_advanced else 'SIMPLE_OPTIMIZATIONS'),
        ('output_format', 'json'),
        ('output_info', 'compiled_code'),
        ('output_info', 'errors'),
        ('exclude_default_externs', 'true')
        ]
    if opts.warnings:
        request_params.append(('output_info', 'warnings'))
    if opts.statistics:
        request_params.append(('output_info', 'statistics'))

    r = urllib.urlopen('https://closure-compiler.appspot.com/compile', urllib.urlencode(request_params))
    response = json.load(r)
    if 'warnings' in response:
        print 'WARNINGS'
        print '=============='
        print pprint.pprint(response['warnings'])
        sys.exit(1)
    if 'errors' in response:
        print 'ERRORS'
        print '=============='
        print pprint.pprint(response['errors'])
        sys.exit(1)
    if 'statistics' in response:
        print 'STATISTICS'
        print '=============='
        print pprint.pprint(response['statistics'])

    return response['compiledCode']

def get_py_jsmin_code(code):
    minifier = jsmin.JavaScriptMinifier()
    return minifier.JSMinify(code)

def get_jsmin_code(code):
    p = subprocess.Popen(['third_party/jsmin'], stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE)
    p.stdin.write(code)
    out, err = p.communicate()
    assert not err, er
    return out

def maybe_replace_file(name, contents):
    # to avoid rebuilding too much (specifically rebuiding state.cc) when
    # bundled_core.{h,cc} are re-generated, we only re-write the contents of
    # files when they actually change
    try:
        with open(name) as f:
            file_hash = hashlib.sha1(f.read()).digest()
    except IOError:
        file_hash = ''
    if not contents.endswith('\n'):
        contents += '\n'
    content_hash = hashlib.sha1(contents).digest()
    if file_hash != content_hash:
        with open(name, 'w') as wf:
            wf.write(contents)

def c_escape_binary_data(data):
    line_size = 18
    splitsrc = []
    while data:
        splitsrc.append(data[:line_size])
        data = data[line_size:]

    escaped_output = []
    for line in splitsrc:
        l = '"%s"' % ''.join('\\x%02x' % ord(c) for c in line)
        escaped_output.append(l)

    return '  ' + '\n  '.join(escaped_output)

def write_output(code, precompilation, output):
    current_year = datetime.date.today().year

    # add a copyright header to the minified JS
    hdr = '// Copyright %d, Evan Klitzke <evan@eklitzke.org>' % current_year
    code = hdr + '\n' + code

    src = c_escape_binary_data(code)
    precompiled_src = c_escape_binary_data(precompilation)

    gentime = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    cc_src = cc_template.strip() % {
        'current_year': current_year,
        'gentime': gentime,
        'src': src,
        'src_len': len(code),
        'precompiled_src': precompiled_src,
        'precompilation_len': len(precompilation)
        }
    h_src = h_template.strip() % {
        'current_year': current_year,
        'gentime': gentime
        }

    maybe_replace_file(output + '.h', h_src)
    maybe_replace_file(output + '.cc', cc_src)

    # create a fake .bundled_core file to please `make'; the reason this is
    # necessary is because Make will get confused if we don't actually end up
    # updating the .h or .cc files
    with open('src/.bundled_core', 'w') as b:
        pass

if __name__ == '__main__':
    parser = optparse.OptionParser()
    parser.add_option('--use-closure', default=False, action='store_true',
                      help='Use closure instead of jsmin (this generates '
                      'significantly more compact JS, but is slower and '
                      'requires network access).')
    parser.add_option('--use-py-jsmin', default=False, action='store_true',
                      help='Use V8\'s jsmin instead of Douglas Crockford\'s')
    parser.add_option('--no-expand-requires', dest='expand_requires', default=True,
                      action='store_false', help="Don't expand requires()")
    parser.add_option('--no-warnings', dest='warnings', default=True, action='store_false', help='Get warnings.')
    parser.add_option('-s', '--statistics', action='store_true', help='Get statistics.')
    parser.add_option('-o', '--outfile', default='src/bundled_core', help='Output file to emit.')
    parser.add_option('-a', '--advanced-optimizations', action='store_true', help='Use ADVANCED_OPTIMIZATIONS with closure.')
    opts, args = parser.parse_args()
    if not opts.outfile:
        parser.error('must have an outfile')
        sys.exit(1)

    code = ['"use strict";']  # enforce strict mode for bundled JS, gh-15
    for filename in args:
        with open(filename) as f:
            code.append(f.read())
    code = '\n'.join(code).strip()
    if opts.expand_requires:
        code = expand_requires(code)

    if opts.use_closure:
        code = get_closure_code(code, opts.advanced_optimizations)
    elif opts.use_py_jsmin:
        code = get_py_jsmin_code(code)
    else:
        code = get_jsmin_code(code)

    p = subprocess.Popen(['scripts/precompile'],
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    p.stdin.write(code)
    out, err = p.communicate()
    assert not err, err
    write_output(code, out, opts.outfile)
