// -*- C++ -*-
// Copyright 2012, Evan Klitzke <evan@eklitzke.org>
//
// This file is AUTOGENERATED by gen_key_sources.py, do not edit by hand!

#include "./keycode.h"

#include <v8.h>

#include <cassert>
#include <string>

#include "./embeddable.h"

using v8::Arguments;
using v8::Boolean;
using v8::External;
using v8::FunctionTemplate;
using v8::Handle;
using v8::HandleScope;
using v8::Integer;
using v8::Object;
using v8::ObjectTemplate;
using v8::String;
using v8::Value;

namespace e {
namespace {
Handle<Value> JSGetChar(const Arguments& args) {
  GET_SELF(KeyCode);

  HandleScope scope;
  char c = self->GetChar();
  Local<String> ch = String::NewSymbol(&c, 1);
  return scope.Close(ch);
}

Handle<Value> JSGetCode(const Arguments& args) {
  GET_SELF(KeyCode);

  HandleScope scope;
  Local<Integer> code = Integer::New(self->GetCode());
  return scope.Close(code);
}

Handle<Value> JSGetName(const Arguments& args) {
  GET_SELF(KeyCode);

  HandleScope scope;
  std::string s = self->GetName();
  Local<String> name = String::NewSymbol(s.c_str(), s.length());
  return scope.Close(name);
}

Handle<Value> JSIsASCII(const Arguments& args) {
  GET_SELF(KeyCode);

  HandleScope scope;
  Handle<Boolean> b = Boolean::New(self->IsASCII());
  return scope.Close(b);
}

Persistent<ObjectTemplate> keycode_template;

// Create a raw template to assign to keycode_template
Handle<ObjectTemplate> MakeKeyCodeTemplate() {
  HandleScope scope;
  Handle<ObjectTemplate> result = ObjectTemplate::New();
  result->SetInternalFieldCount(1);
  result->Set(String::New("getChar"), FunctionTemplate::New(JSGetChar),
    v8::ReadOnly);
  result->Set(String::New("getCode"), FunctionTemplate::New(JSGetCode),
    v8::ReadOnly);
  result->Set(String::New("getName"), FunctionTemplate::New(JSGetName),
    v8::ReadOnly);
  result->Set(String::New("isASCII"), FunctionTemplate::New(JSIsASCII),
    v8::ReadOnly);
  return scope.Close(result);
}
}

KeyCode::KeyCode(int code, const std::string &short_name)
    :code_(code), short_name_(short_name) {
}

KeyCode::KeyCode(int code)
    :code_(code) {
}

KeyCode::~KeyCode() {
}

namespace {
// this callback will be invoked when the V8 keypress object is GC'ed
void CleanupKeycode(Persistent<Value> val, void*) {
  HandleScope scope;
  assert(val->IsObject());
  Local<Object> obj = val->ToObject();
  KeyCode *kc = Unwrap<KeyCode>(obj);
  delete kc;
  val.Dispose();
}
}

Persistent<Value> KeyCode::ToScript() {
  HandleScope scope;

  if (keycode_template.IsEmpty()) {
    Handle<ObjectTemplate> raw_template = MakeKeyCodeTemplate();
    keycode_template = Persistent<ObjectTemplate>::New(raw_template);
  }

  //Local<Object> kc_local = keycode_template->NewInstance();
  Persistent<Object> kc = Persistent<Object>::New(keycode_template->NewInstance());

  kc.MakeWeak(nullptr, CleanupKeycode);

  assert(kc->InternalFieldCount() == 1);
  kc->SetInternalField(0, External::New(this));
  //return scope.Close(kc);
  return kc;
}

const std::string& KeyCode::GetName(void) const {
  return short_name_;
}

bool KeyCode::IsASCII(void) const {
  return code_ <= 0xff;
}

int KeyCode::GetCode(void) const {
  return code_;
}

// XXX: it's unspecified whether this is a signed or unsigned char!
char KeyCode::GetChar(void) const {
  if (code_ > 0xff) {
    return static_cast<char>(code_ & 0xff);
  } else {
    return static_cast<char>(code_);
  }
}

namespace keycode {
  const size_t max_code = 409;
  const char * keycode_arr[410] = {
      "\x00",
      "\x01",
      "\x02",
      "\x03",
      "\x04",
      "\x05",
      "\x06",
      "\x07",
      "\x08",
      "\x09",
      "\x0a",
      "\x0b",
      "\x0c",
      "\x0d",
      "\x0e",
      "\x0f",
      "\x10",
      "\x11",
      "\x12",
      "\x13",
      "\x14",
      "\x15",
      "\x16",
      "\x17",
      "\x18",
      "\x19",
      "\x1a",
      "\x1b",
      "\x1c",
      "\x1d",
      "\x1e",
      "\x1f",
      " ",
      "!",
      "\"",
      "#",
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      ":",
      ";",
      "<",
      "=",
      ">",
      "?",
      "@",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "{",
      "|",
      "}",
      "~",
      "\x7f",
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      "key_down",             // down-arrow key
      "key_up",               // up-arrow key
      "key_left",             // left-arrow key
      "key_right",            // right-arrow key
      "key_home",             // home key
      "key_backspace",        // backspace key
      "key_f0",               // F0 function key
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
      "key_dl",               // delete-line key
      "key_il",               // insert-line key
      "key_dc",               // delete-character key
      "key_ic",               // insert-character key
      "key_eic",              // sent by rmir or smir in insert mode
      "key_clear",            // clear-screen or erase key
      "key_eos",              // clear-to-end-of-screen key
      "key_eol",              // clear-to-end-of-line key
      "key_sf",               // scroll-forward key
      "key_sr",               // scroll-backward key
      "key_npage",            // next-page key
      "key_ppage",            // previous-page key
      "key_stab",             // set-tab key
      "key_ctab",             // clear-tab key
      "key_catab",            // clear-all-tabs key
      "key_enter",            // enter/send key
      nullptr,
      nullptr,
      "key_print",            // print key
      "key_ll",               // lower-left key (home down)
      "key_a1",               // upper left of keypad
      "key_a3",               // upper right of keypad
      "key_b2",               // center of keypad
      "key_c1",               // lower left of keypad
      "key_c3",               // lower right of keypad
      "key_btab",             // back-tab key
      "key_beg",              // begin key
      "key_cancel",           // cancel key
      "key_close",            // close key
      "key_command",          // command key
      "key_copy",             // copy key
      "key_create",           // create key
      "key_end",              // end key
      "key_exit",             // exit key
      "key_find",             // find key
      "key_help",             // help key
      "key_mark",             // mark key
      "key_message",          // message key
      "key_move",             // move key
      "key_next",             // next key
      "key_open",             // open key
      "key_options",          // options key
      "key_previous",         // previous key
      "key_redo",             // redo key
      "key_reference",        // reference key
      "key_refresh",          // refresh key
      "key_replace",          // replace key
      "key_restart",          // restart key
      "key_resume",           // resume key
      "key_save",             // save key
      "key_sbeg",             // shifted begin key
      "key_scancel",          // shifted cancel key
      "key_scommand",         // shifted command key
      "key_scopy",            // shifted copy key
      "key_screate",          // shifted create key
      "key_sdc",              // shifted delete-character key
      "key_sdl",              // shifted delete-line key
      "key_select",           // select key
      "key_send",             // shifted end key
      "key_seol",             // shifted clear-to-end-of-line key
      "key_sexit",            // shifted exit key
      "key_sfind",            // shifted find key
      "key_shelp",            // shifted help key
      "key_shome",            // shifted home key
      "key_sic",              // shifted insert-character key
      "key_sleft",            // shifted left-arrow key
      "key_smessage",         // shifted message key
      "key_smove",            // shifted move key
      "key_snext",            // shifted next key
      "key_soptions",         // shifted options key
      "key_sprevious",        // shifted previous key
      "key_sprint",           // shifted print key
      "key_sredo",            // shifted redo key
      "key_sreplace",         // shifted replace key
      "key_sright",           // shifted right-arrow key
      "key_srsume",           // shifted resume key
      "key_ssave",            // shifted save key
      "key_ssuspend",         // shifted suspend key
      "key_sundo",            // shifted undo key
      "key_suspend",          // suspend key
      "key_undo",             // undo key
      "key_mouse",            // Mouse event has occurred
  };

  KeyCode* curses_code_to_keycode(int code) {
    size_t offset = static_cast<size_t>(code);
    assert(offset <= max_code);
    const char *name = keycode_arr[offset];

    // The returned pointers are "owned" by V8; the way they'll get deleted
    // later on is by CleanupKeycode, which will be invoked when the containing
    // V8 object is garbage collected.
    if (name == nullptr) {
      return new KeyCode(code);
    } else {
      return new KeyCode(code, name);
    }
  }
}
}
